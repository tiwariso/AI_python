# -*- coding: utf-8 -*-
"""AI_C3_42_practical2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OY9pB54apDdDP_jRC_lFj5UBSWVNitaS

A) Write a program to implement 2 water jug problems with BFS approach.
"""

#  A) Write a program to implement 2 water jug problems with BFS approach.

from collections import deque

def water_jug_bfs(jug1_capacity, jug2_capacity, target):
    """
    Solves the water jug problem using Breadth-First Search.

    Args:
        jug1_capacity: Capacity of the first jug.
        jug2_capacity: Capacity of the second jug.
        target: Target amount of water to achieve.

    Returns:
        A list of tuples representing the states of the jugs, or None if no solution is found.
    """

    visited = set()
    queue = deque([(0, 0, [])])  # (jug1_level, jug2_level, path)
    visited.add((0, 0))

    while queue:
        jug1_level, jug2_level, path = queue.popleft()

        if jug1_level == target or jug2_level == target:
            return path + [(jug1_level, jug2_level)]

        # Possible actions:
        actions = [
            (jug1_capacity, jug2_level),  # Fill jug1
            (jug1_level, jug2_capacity),  # Fill jug2
            (0, jug2_level),  # Empty jug1
            (jug1_level, 0),  # Empty jug2
            (min(jug1_capacity, jug1_level + jug2_level), max(0, jug1_level + jug2_level - jug1_capacity)),  # Pour jug2 into jug1
            (max(0, jug1_level + jug2_level - jug2_capacity), min(jug2_capacity, jug1_level + jug2_level))  # Pour jug1 into jug2
        ]


        for next_jug1, next_jug2 in actions:

            if (next_jug1, next_jug2) not in visited:
                visited.add((next_jug1, next_jug2))
                queue.append((next_jug1, next_jug2, path + [(jug1_level, jug2_level)]))

    return None

# Example usage:
jug1_capacity = 4
jug2_capacity = 3
target_amount = 2

solution = water_jug_bfs(jug1_capacity, jug2_capacity, target_amount)


if solution:
    print(f"Solution found for jugs with capacities ({jug1_capacity}, {jug2_capacity}) and target {target_amount}:")
    for state in solution:
        print(state)
else:
    print(f"No solution found for jugs with capacities ({jug1_capacity}, {jug2_capacity}) and target {target_amount}.")


jug1_capacity = 5
jug2_capacity = 2
target_amount = 4

solution = water_jug_bfs(jug1_capacity, jug2_capacity, target_amount)

if solution:
  print(f"Solution found for jugs with capacities ({jug1_capacity}, {jug2_capacity}) and target {target_amount}:")
  for state in solution:
      print(state)
else:
    print(f"No solution found for jugs with capacities ({jug1_capacity}, {jug2_capacity}) and target {target_amount}.")

"""B) Write a program to implement BFS approach on the given graph."""

#  B) Write a program to implement BFS approach on the given graph.

from collections import deque

def bfs(graph, start_node):
    """
    Performs Breadth-First Search on a graph.

    Args:
        graph: A dictionary representing the graph where keys are nodes and values are lists of neighbors.
        start_node: The starting node for the BFS traversal.

    Returns:
        A list of nodes in the order they were visited during BFS.
    """
    visited = set()
    queue = deque([start_node])
    visited.add(start_node)
    traversal_order = []

    while queue:
        current_node = queue.popleft()
        traversal_order.append(current_node)

        if current_node not in graph:
          continue

        for neighbor in graph[current_node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return traversal_order


# Example graph represented as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

start_node = 'A'
bfs_order = bfs(graph, start_node)
print(f"BFS traversal starting from node {start_node}: {bfs_order}")

"""C) Write a program to implement DFS approach on the given graph."""

#  C) Write a program to implement DFS approach on the given graph.

def dfs(graph, start_node):
    """
    Performs Depth-First Search on a graph.

    Args:
        graph: A dictionary representing the graph where keys are nodes and values are lists of neighbors.
        start_node: The starting node for the DFS traversal.

    Returns:
        A list of nodes in the order they were visited during DFS.
    """
    visited = set()
    traversal_order = []

    def _dfs(node):
        visited.add(node)
        traversal_order.append(node)

        if node not in graph:
          return

        for neighbor in graph[node]:
            if neighbor not in visited:
                _dfs(neighbor)

    _dfs(start_node)
    return traversal_order

# Example graph represented as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

start_node = 'A'
dfs_order = dfs(graph, start_node)
print(f"DFS traversal starting from node {start_node}: {dfs_order}")

