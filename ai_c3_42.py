# -*- coding: utf-8 -*-
"""AI_C3_42.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jRpn4t6dluB1JJV0a24FSiPGe1rdM7Bl
"""

# A) Solving 2 water jug Problem:
# b) Write a program to solve the 2 water jug problem by sequentially calling operators automatically.
def water_jug_manual(jug1_cap, jug2_cap, target):
    jug1 = 0
    jug2 = 0
    print("Initial state: (", jug1, ",", jug2, ")")
    while jug1 != target and jug2 != target:
        print("\nPossible moves:")
        print("1. Fill Jug 1")
        print("2. Fill Jug 2")
        print("3. Empty Jug 1")
        print("4. Empty Jug 2")
        print("5. Pour Jug 1 into Jug 2")
        print("6. Pour Jug 2 into Jug 1")

        move = int(input("Enter your move (1-6): "))

        if move == 1:
            jug1 = jug1_cap
        elif move == 2:
            jug2 = jug2_cap
        elif move == 3:
            jug1 = 0
        elif move == 4:
            jug2 = 0
        elif move == 5:
            pour_amount = min(jug1, jug2_cap - jug2)
            jug1 -= pour_amount
            jug2 += pour_amount
        elif move == 6:
            pour_amount = min(jug2, jug1_cap - jug1)
            jug2 -= pour_amount
            jug1 += pour_amount
        else:
            print("Invalid move.")
            continue

        print("Current state: (", jug1, ",", jug2, ")")
        if jug1 == target or jug2 == target:
            print("Target achieved!")
            break



water_jug_manual(4, 3, 2)

# b) Write a program to solve the 2 water jug problem by sequentially calling operators automatically.

def water_jug_auto(jug1_cap, jug2_cap, target):
    jug1 = 0
    jug2 = 0
    visited = set()
    queue = [(jug1, jug2, [])]  # (jug1_level, jug2_level, path)

    while queue:
        jug1, jug2, path = queue.pop(0)
        if (jug1, jug2) in visited:
            continue
        visited.add((jug1, jug2))

        print("Current state: (", jug1, ",", jug2, ")")

        if jug1 == target or jug2 == target:
            print("Target achieved!")
            for step in path:
                print(step)
            return

        # Possible moves
        moves = [
            (jug1_cap, jug2, "Fill Jug 1"),
            (jug1, jug2_cap, "Fill Jug 2"),
            (0, jug2, "Empty Jug 1"),
            (jug1, 0, "Empty Jug 2"),
            (
                max(0, jug1 - (jug2_cap - jug2)),
                min(jug2_cap, jug1 + jug2),
                "Pour Jug 1 into Jug 2",
            ),
            (
                min(jug1_cap, jug1 + jug2),
                max(0, jug2 - (jug1_cap - jug1)),
                "Pour Jug 2 into Jug 1",
            ),
        ]

        for next_jug1, next_jug2, move_description in moves:
          if (next_jug1, next_jug2) not in visited:
            queue.append((next_jug1, next_jug2, path + [move_description]))
    print("Target cannot be achieved.")


water_jug_auto(4, 3, 2)

# B) Write a program to implement Missionaries and Cannibals problem. Constraints: three missionaries and three cannibals must cross a river using a boat which can carry at most two people, under the constraint that, for both banks, if there are missionaries present on the bank, they cannot be outnumbered by cannibals (if they were, the cannibals would eat the missionaries). The boat cannot cross the river by itself with no people on board.

from collections import deque

def is_valid(missionaries, cannibals):
    return (missionaries == 0 or missionaries >= cannibals) and \
           (3 - missionaries == 0 or 3 - missionaries >= 3 - cannibals)

def solve_missionaries_cannibals():
    initial_state = (3, 3, 1)  # (missionaries, cannibals, boat_side)
    target_state = (0, 0, 0)
    queue = deque([(initial_state, [])])
    visited = set()

    while queue:
        (m, c, b), path = queue.popleft()
        if (m, c, b) == target_state:
            print("Solution found:")
            for step in path:
                print(step)
            return

        visited.add((m,c,b))

        for i in range(3):
            for j in range(3):
                if 0 < i + j <= 2:  # Boat capacity
                    next_m = m - (i if b == 1 else -i)
                    next_c = c - (j if b == 1 else -j)
                    next_b = 1 - b

                    if 0 <= next_m <= 3 and 0 <= next_c <= 3 and is_valid(next_m, next_c) and is_valid(3-next_m, 3-next_c) and ((next_m, next_c, next_b) not in visited):
                        queue.append(((next_m, next_c, next_b), path + [f"Move {i} missionaries and {j} cannibals from {'left' if b == 1 else 'right'} to {'right' if b == 1 else 'left'}" ]))

    print("No solution found.")

solve_missionaries_cannibals()

