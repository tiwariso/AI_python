# -*- coding: utf-8 -*-
"""practical_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ij1PFpR9b84H8Fg32WYmC3RPbU_Gj23o
"""

import random

# Departments and their interaction frequencies
departments = ["Assembly", "Packaging", "Quality ", "Storage", "Shipping"]
interaction_matrix = [
    [0,50,70,30,10],  # A
    [50,0,30,60,70],  # P
    [70,30,0,50,30],  # Q
    [30,60,50,0,60],  # St
    [10,70,30,60,0],  # Sh
]

# Initial random layout on a 3x3 grid
initial_layout = random.sample(departments + [None] * 4, 9)

def calculate_cost(layout):
    cost = 0
    positions = {dept: idx for idx, dept in enumerate(layout) if dept}

    for i, dept1 in enumerate(departments):
        for j, dept2 in enumerate(departments):
            if dept1 != dept2:
                pos1 = divmod(positions[dept1], 3)
                pos2 = divmod(positions[dept2], 3)
                distance = abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])
                cost += interaction_matrix[i][j] * distance
    return cost

def hill_climbing(layout):
    current_layout = layout[:]
    current_cost = calculate_cost(current_layout)

    while True:
        neighbors = []
        for i in range(9):
            for j in range(i + 1, 9):
                neighbor = current_layout[:]
                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
                neighbors.append(neighbor)

        best_neighbor = min(neighbors, key=calculate_cost)
        best_neighbor_cost = calculate_cost(best_neighbor)

        if best_neighbor_cost < current_cost:
            current_layout = best_neighbor
            current_cost = best_neighbor_cost
        else:
            break

    return current_layout, current_cost

# Run the algorithm
optimized_layout, minimized_cost = hill_climbing(initial_layout)
print("Optimized Layout:", optimized_layout)
print("Minimized Cost:", minimized_cost)

